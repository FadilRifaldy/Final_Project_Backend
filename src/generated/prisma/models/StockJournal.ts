
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `StockJournal` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model StockJournal
 * 
 */
export type StockJournalModel = runtime.Types.Result.DefaultSelection<Prisma.$StockJournalPayload>

export type AggregateStockJournal = {
  _count: StockJournalCountAggregateOutputType | null
  _avg: StockJournalAvgAggregateOutputType | null
  _sum: StockJournalSumAggregateOutputType | null
  _min: StockJournalMinAggregateOutputType | null
  _max: StockJournalMaxAggregateOutputType | null
}

export type StockJournalAvgAggregateOutputType = {
  quantity: number | null
  stockBefore: number | null
  stockAfter: number | null
}

export type StockJournalSumAggregateOutputType = {
  quantity: number | null
  stockBefore: number | null
  stockAfter: number | null
}

export type StockJournalMinAggregateOutputType = {
  id: string | null
  productVariantId: string | null
  warehouseId: string | null
  type: $Enums.StockJournalType | null
  quantity: number | null
  stockBefore: number | null
  stockAfter: number | null
  referenceNo: string | null
  reason: string | null
  notes: string | null
  relatedOrderId: string | null
  createdBy: string | null
  createdAt: Date | null
}

export type StockJournalMaxAggregateOutputType = {
  id: string | null
  productVariantId: string | null
  warehouseId: string | null
  type: $Enums.StockJournalType | null
  quantity: number | null
  stockBefore: number | null
  stockAfter: number | null
  referenceNo: string | null
  reason: string | null
  notes: string | null
  relatedOrderId: string | null
  createdBy: string | null
  createdAt: Date | null
}

export type StockJournalCountAggregateOutputType = {
  id: number
  productVariantId: number
  warehouseId: number
  type: number
  quantity: number
  stockBefore: number
  stockAfter: number
  referenceNo: number
  reason: number
  notes: number
  relatedOrderId: number
  createdBy: number
  createdAt: number
  _all: number
}


export type StockJournalAvgAggregateInputType = {
  quantity?: true
  stockBefore?: true
  stockAfter?: true
}

export type StockJournalSumAggregateInputType = {
  quantity?: true
  stockBefore?: true
  stockAfter?: true
}

export type StockJournalMinAggregateInputType = {
  id?: true
  productVariantId?: true
  warehouseId?: true
  type?: true
  quantity?: true
  stockBefore?: true
  stockAfter?: true
  referenceNo?: true
  reason?: true
  notes?: true
  relatedOrderId?: true
  createdBy?: true
  createdAt?: true
}

export type StockJournalMaxAggregateInputType = {
  id?: true
  productVariantId?: true
  warehouseId?: true
  type?: true
  quantity?: true
  stockBefore?: true
  stockAfter?: true
  referenceNo?: true
  reason?: true
  notes?: true
  relatedOrderId?: true
  createdBy?: true
  createdAt?: true
}

export type StockJournalCountAggregateInputType = {
  id?: true
  productVariantId?: true
  warehouseId?: true
  type?: true
  quantity?: true
  stockBefore?: true
  stockAfter?: true
  referenceNo?: true
  reason?: true
  notes?: true
  relatedOrderId?: true
  createdBy?: true
  createdAt?: true
  _all?: true
}

export type StockJournalAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which StockJournal to aggregate.
   */
  where?: Prisma.StockJournalWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of StockJournals to fetch.
   */
  orderBy?: Prisma.StockJournalOrderByWithRelationInput | Prisma.StockJournalOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.StockJournalWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` StockJournals from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` StockJournals.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned StockJournals
  **/
  _count?: true | StockJournalCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: StockJournalAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: StockJournalSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: StockJournalMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: StockJournalMaxAggregateInputType
}

export type GetStockJournalAggregateType<T extends StockJournalAggregateArgs> = {
      [P in keyof T & keyof AggregateStockJournal]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateStockJournal[P]>
    : Prisma.GetScalarType<T[P], AggregateStockJournal[P]>
}




export type StockJournalGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.StockJournalWhereInput
  orderBy?: Prisma.StockJournalOrderByWithAggregationInput | Prisma.StockJournalOrderByWithAggregationInput[]
  by: Prisma.StockJournalScalarFieldEnum[] | Prisma.StockJournalScalarFieldEnum
  having?: Prisma.StockJournalScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: StockJournalCountAggregateInputType | true
  _avg?: StockJournalAvgAggregateInputType
  _sum?: StockJournalSumAggregateInputType
  _min?: StockJournalMinAggregateInputType
  _max?: StockJournalMaxAggregateInputType
}

export type StockJournalGroupByOutputType = {
  id: string
  productVariantId: string
  warehouseId: string
  type: $Enums.StockJournalType
  quantity: number
  stockBefore: number
  stockAfter: number
  referenceNo: string
  reason: string
  notes: string | null
  relatedOrderId: string | null
  createdBy: string
  createdAt: Date
  _count: StockJournalCountAggregateOutputType | null
  _avg: StockJournalAvgAggregateOutputType | null
  _sum: StockJournalSumAggregateOutputType | null
  _min: StockJournalMinAggregateOutputType | null
  _max: StockJournalMaxAggregateOutputType | null
}

type GetStockJournalGroupByPayload<T extends StockJournalGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<StockJournalGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof StockJournalGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], StockJournalGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], StockJournalGroupByOutputType[P]>
      }
    >
  >



export type StockJournalWhereInput = {
  AND?: Prisma.StockJournalWhereInput | Prisma.StockJournalWhereInput[]
  OR?: Prisma.StockJournalWhereInput[]
  NOT?: Prisma.StockJournalWhereInput | Prisma.StockJournalWhereInput[]
  id?: Prisma.StringFilter<"StockJournal"> | string
  productVariantId?: Prisma.StringFilter<"StockJournal"> | string
  warehouseId?: Prisma.StringFilter<"StockJournal"> | string
  type?: Prisma.EnumStockJournalTypeFilter<"StockJournal"> | $Enums.StockJournalType
  quantity?: Prisma.IntFilter<"StockJournal"> | number
  stockBefore?: Prisma.IntFilter<"StockJournal"> | number
  stockAfter?: Prisma.IntFilter<"StockJournal"> | number
  referenceNo?: Prisma.StringFilter<"StockJournal"> | string
  reason?: Prisma.StringFilter<"StockJournal"> | string
  notes?: Prisma.StringNullableFilter<"StockJournal"> | string | null
  relatedOrderId?: Prisma.StringNullableFilter<"StockJournal"> | string | null
  createdBy?: Prisma.StringFilter<"StockJournal"> | string
  createdAt?: Prisma.DateTimeFilter<"StockJournal"> | Date | string
  productVariant?: Prisma.XOR<Prisma.ProductVariantScalarRelationFilter, Prisma.ProductVariantWhereInput>
  warehouse?: Prisma.XOR<Prisma.WarehouseScalarRelationFilter, Prisma.WarehouseWhereInput>
  creator?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  order?: Prisma.XOR<Prisma.OrderNullableScalarRelationFilter, Prisma.OrderWhereInput> | null
}

export type StockJournalOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  productVariantId?: Prisma.SortOrder
  warehouseId?: Prisma.SortOrder
  type?: Prisma.SortOrder
  quantity?: Prisma.SortOrder
  stockBefore?: Prisma.SortOrder
  stockAfter?: Prisma.SortOrder
  referenceNo?: Prisma.SortOrder
  reason?: Prisma.SortOrder
  notes?: Prisma.SortOrderInput | Prisma.SortOrder
  relatedOrderId?: Prisma.SortOrderInput | Prisma.SortOrder
  createdBy?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  productVariant?: Prisma.ProductVariantOrderByWithRelationInput
  warehouse?: Prisma.WarehouseOrderByWithRelationInput
  creator?: Prisma.UserOrderByWithRelationInput
  order?: Prisma.OrderOrderByWithRelationInput
}

export type StockJournalWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.StockJournalWhereInput | Prisma.StockJournalWhereInput[]
  OR?: Prisma.StockJournalWhereInput[]
  NOT?: Prisma.StockJournalWhereInput | Prisma.StockJournalWhereInput[]
  productVariantId?: Prisma.StringFilter<"StockJournal"> | string
  warehouseId?: Prisma.StringFilter<"StockJournal"> | string
  type?: Prisma.EnumStockJournalTypeFilter<"StockJournal"> | $Enums.StockJournalType
  quantity?: Prisma.IntFilter<"StockJournal"> | number
  stockBefore?: Prisma.IntFilter<"StockJournal"> | number
  stockAfter?: Prisma.IntFilter<"StockJournal"> | number
  referenceNo?: Prisma.StringFilter<"StockJournal"> | string
  reason?: Prisma.StringFilter<"StockJournal"> | string
  notes?: Prisma.StringNullableFilter<"StockJournal"> | string | null
  relatedOrderId?: Prisma.StringNullableFilter<"StockJournal"> | string | null
  createdBy?: Prisma.StringFilter<"StockJournal"> | string
  createdAt?: Prisma.DateTimeFilter<"StockJournal"> | Date | string
  productVariant?: Prisma.XOR<Prisma.ProductVariantScalarRelationFilter, Prisma.ProductVariantWhereInput>
  warehouse?: Prisma.XOR<Prisma.WarehouseScalarRelationFilter, Prisma.WarehouseWhereInput>
  creator?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  order?: Prisma.XOR<Prisma.OrderNullableScalarRelationFilter, Prisma.OrderWhereInput> | null
}, "id">

export type StockJournalOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  productVariantId?: Prisma.SortOrder
  warehouseId?: Prisma.SortOrder
  type?: Prisma.SortOrder
  quantity?: Prisma.SortOrder
  stockBefore?: Prisma.SortOrder
  stockAfter?: Prisma.SortOrder
  referenceNo?: Prisma.SortOrder
  reason?: Prisma.SortOrder
  notes?: Prisma.SortOrderInput | Prisma.SortOrder
  relatedOrderId?: Prisma.SortOrderInput | Prisma.SortOrder
  createdBy?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  _count?: Prisma.StockJournalCountOrderByAggregateInput
  _avg?: Prisma.StockJournalAvgOrderByAggregateInput
  _max?: Prisma.StockJournalMaxOrderByAggregateInput
  _min?: Prisma.StockJournalMinOrderByAggregateInput
  _sum?: Prisma.StockJournalSumOrderByAggregateInput
}

export type StockJournalScalarWhereWithAggregatesInput = {
  AND?: Prisma.StockJournalScalarWhereWithAggregatesInput | Prisma.StockJournalScalarWhereWithAggregatesInput[]
  OR?: Prisma.StockJournalScalarWhereWithAggregatesInput[]
  NOT?: Prisma.StockJournalScalarWhereWithAggregatesInput | Prisma.StockJournalScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"StockJournal"> | string
  productVariantId?: Prisma.StringWithAggregatesFilter<"StockJournal"> | string
  warehouseId?: Prisma.StringWithAggregatesFilter<"StockJournal"> | string
  type?: Prisma.EnumStockJournalTypeWithAggregatesFilter<"StockJournal"> | $Enums.StockJournalType
  quantity?: Prisma.IntWithAggregatesFilter<"StockJournal"> | number
  stockBefore?: Prisma.IntWithAggregatesFilter<"StockJournal"> | number
  stockAfter?: Prisma.IntWithAggregatesFilter<"StockJournal"> | number
  referenceNo?: Prisma.StringWithAggregatesFilter<"StockJournal"> | string
  reason?: Prisma.StringWithAggregatesFilter<"StockJournal"> | string
  notes?: Prisma.StringNullableWithAggregatesFilter<"StockJournal"> | string | null
  relatedOrderId?: Prisma.StringNullableWithAggregatesFilter<"StockJournal"> | string | null
  createdBy?: Prisma.StringWithAggregatesFilter<"StockJournal"> | string
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"StockJournal"> | Date | string
}

export type StockJournalCreateInput = {
  id?: string
  type: $Enums.StockJournalType
  quantity: number
  stockBefore: number
  stockAfter: number
  referenceNo: string
  reason: string
  notes?: string | null
  createdAt?: Date | string
  productVariant: Prisma.ProductVariantCreateNestedOneWithoutStockJournalsInput
  warehouse: Prisma.WarehouseCreateNestedOneWithoutStockJournalsInput
  creator: Prisma.UserCreateNestedOneWithoutStockJournalsInput
  order?: Prisma.OrderCreateNestedOneWithoutStockJournalsInput
}

export type StockJournalUncheckedCreateInput = {
  id?: string
  productVariantId: string
  warehouseId: string
  type: $Enums.StockJournalType
  quantity: number
  stockBefore: number
  stockAfter: number
  referenceNo: string
  reason: string
  notes?: string | null
  relatedOrderId?: string | null
  createdBy: string
  createdAt?: Date | string
}

export type StockJournalUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumStockJournalTypeFieldUpdateOperationsInput | $Enums.StockJournalType
  quantity?: Prisma.IntFieldUpdateOperationsInput | number
  stockBefore?: Prisma.IntFieldUpdateOperationsInput | number
  stockAfter?: Prisma.IntFieldUpdateOperationsInput | number
  referenceNo?: Prisma.StringFieldUpdateOperationsInput | string
  reason?: Prisma.StringFieldUpdateOperationsInput | string
  notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  productVariant?: Prisma.ProductVariantUpdateOneRequiredWithoutStockJournalsNestedInput
  warehouse?: Prisma.WarehouseUpdateOneRequiredWithoutStockJournalsNestedInput
  creator?: Prisma.UserUpdateOneRequiredWithoutStockJournalsNestedInput
  order?: Prisma.OrderUpdateOneWithoutStockJournalsNestedInput
}

export type StockJournalUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  productVariantId?: Prisma.StringFieldUpdateOperationsInput | string
  warehouseId?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumStockJournalTypeFieldUpdateOperationsInput | $Enums.StockJournalType
  quantity?: Prisma.IntFieldUpdateOperationsInput | number
  stockBefore?: Prisma.IntFieldUpdateOperationsInput | number
  stockAfter?: Prisma.IntFieldUpdateOperationsInput | number
  referenceNo?: Prisma.StringFieldUpdateOperationsInput | string
  reason?: Prisma.StringFieldUpdateOperationsInput | string
  notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  relatedOrderId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdBy?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type StockJournalCreateManyInput = {
  id?: string
  productVariantId: string
  warehouseId: string
  type: $Enums.StockJournalType
  quantity: number
  stockBefore: number
  stockAfter: number
  referenceNo: string
  reason: string
  notes?: string | null
  relatedOrderId?: string | null
  createdBy: string
  createdAt?: Date | string
}

export type StockJournalUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumStockJournalTypeFieldUpdateOperationsInput | $Enums.StockJournalType
  quantity?: Prisma.IntFieldUpdateOperationsInput | number
  stockBefore?: Prisma.IntFieldUpdateOperationsInput | number
  stockAfter?: Prisma.IntFieldUpdateOperationsInput | number
  referenceNo?: Prisma.StringFieldUpdateOperationsInput | string
  reason?: Prisma.StringFieldUpdateOperationsInput | string
  notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type StockJournalUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  productVariantId?: Prisma.StringFieldUpdateOperationsInput | string
  warehouseId?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumStockJournalTypeFieldUpdateOperationsInput | $Enums.StockJournalType
  quantity?: Prisma.IntFieldUpdateOperationsInput | number
  stockBefore?: Prisma.IntFieldUpdateOperationsInput | number
  stockAfter?: Prisma.IntFieldUpdateOperationsInput | number
  referenceNo?: Prisma.StringFieldUpdateOperationsInput | string
  reason?: Prisma.StringFieldUpdateOperationsInput | string
  notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  relatedOrderId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdBy?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type StockJournalListRelationFilter = {
  every?: Prisma.StockJournalWhereInput
  some?: Prisma.StockJournalWhereInput
  none?: Prisma.StockJournalWhereInput
}

export type StockJournalOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type StockJournalCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  productVariantId?: Prisma.SortOrder
  warehouseId?: Prisma.SortOrder
  type?: Prisma.SortOrder
  quantity?: Prisma.SortOrder
  stockBefore?: Prisma.SortOrder
  stockAfter?: Prisma.SortOrder
  referenceNo?: Prisma.SortOrder
  reason?: Prisma.SortOrder
  notes?: Prisma.SortOrder
  relatedOrderId?: Prisma.SortOrder
  createdBy?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type StockJournalAvgOrderByAggregateInput = {
  quantity?: Prisma.SortOrder
  stockBefore?: Prisma.SortOrder
  stockAfter?: Prisma.SortOrder
}

export type StockJournalMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  productVariantId?: Prisma.SortOrder
  warehouseId?: Prisma.SortOrder
  type?: Prisma.SortOrder
  quantity?: Prisma.SortOrder
  stockBefore?: Prisma.SortOrder
  stockAfter?: Prisma.SortOrder
  referenceNo?: Prisma.SortOrder
  reason?: Prisma.SortOrder
  notes?: Prisma.SortOrder
  relatedOrderId?: Prisma.SortOrder
  createdBy?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type StockJournalMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  productVariantId?: Prisma.SortOrder
  warehouseId?: Prisma.SortOrder
  type?: Prisma.SortOrder
  quantity?: Prisma.SortOrder
  stockBefore?: Prisma.SortOrder
  stockAfter?: Prisma.SortOrder
  referenceNo?: Prisma.SortOrder
  reason?: Prisma.SortOrder
  notes?: Prisma.SortOrder
  relatedOrderId?: Prisma.SortOrder
  createdBy?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type StockJournalSumOrderByAggregateInput = {
  quantity?: Prisma.SortOrder
  stockBefore?: Prisma.SortOrder
  stockAfter?: Prisma.SortOrder
}

export type StockJournalCreateNestedManyWithoutCreatorInput = {
  create?: Prisma.XOR<Prisma.StockJournalCreateWithoutCreatorInput, Prisma.StockJournalUncheckedCreateWithoutCreatorInput> | Prisma.StockJournalCreateWithoutCreatorInput[] | Prisma.StockJournalUncheckedCreateWithoutCreatorInput[]
  connectOrCreate?: Prisma.StockJournalCreateOrConnectWithoutCreatorInput | Prisma.StockJournalCreateOrConnectWithoutCreatorInput[]
  createMany?: Prisma.StockJournalCreateManyCreatorInputEnvelope
  connect?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
}

export type StockJournalUncheckedCreateNestedManyWithoutCreatorInput = {
  create?: Prisma.XOR<Prisma.StockJournalCreateWithoutCreatorInput, Prisma.StockJournalUncheckedCreateWithoutCreatorInput> | Prisma.StockJournalCreateWithoutCreatorInput[] | Prisma.StockJournalUncheckedCreateWithoutCreatorInput[]
  connectOrCreate?: Prisma.StockJournalCreateOrConnectWithoutCreatorInput | Prisma.StockJournalCreateOrConnectWithoutCreatorInput[]
  createMany?: Prisma.StockJournalCreateManyCreatorInputEnvelope
  connect?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
}

export type StockJournalUpdateManyWithoutCreatorNestedInput = {
  create?: Prisma.XOR<Prisma.StockJournalCreateWithoutCreatorInput, Prisma.StockJournalUncheckedCreateWithoutCreatorInput> | Prisma.StockJournalCreateWithoutCreatorInput[] | Prisma.StockJournalUncheckedCreateWithoutCreatorInput[]
  connectOrCreate?: Prisma.StockJournalCreateOrConnectWithoutCreatorInput | Prisma.StockJournalCreateOrConnectWithoutCreatorInput[]
  upsert?: Prisma.StockJournalUpsertWithWhereUniqueWithoutCreatorInput | Prisma.StockJournalUpsertWithWhereUniqueWithoutCreatorInput[]
  createMany?: Prisma.StockJournalCreateManyCreatorInputEnvelope
  set?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  disconnect?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  delete?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  connect?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  update?: Prisma.StockJournalUpdateWithWhereUniqueWithoutCreatorInput | Prisma.StockJournalUpdateWithWhereUniqueWithoutCreatorInput[]
  updateMany?: Prisma.StockJournalUpdateManyWithWhereWithoutCreatorInput | Prisma.StockJournalUpdateManyWithWhereWithoutCreatorInput[]
  deleteMany?: Prisma.StockJournalScalarWhereInput | Prisma.StockJournalScalarWhereInput[]
}

export type StockJournalUncheckedUpdateManyWithoutCreatorNestedInput = {
  create?: Prisma.XOR<Prisma.StockJournalCreateWithoutCreatorInput, Prisma.StockJournalUncheckedCreateWithoutCreatorInput> | Prisma.StockJournalCreateWithoutCreatorInput[] | Prisma.StockJournalUncheckedCreateWithoutCreatorInput[]
  connectOrCreate?: Prisma.StockJournalCreateOrConnectWithoutCreatorInput | Prisma.StockJournalCreateOrConnectWithoutCreatorInput[]
  upsert?: Prisma.StockJournalUpsertWithWhereUniqueWithoutCreatorInput | Prisma.StockJournalUpsertWithWhereUniqueWithoutCreatorInput[]
  createMany?: Prisma.StockJournalCreateManyCreatorInputEnvelope
  set?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  disconnect?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  delete?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  connect?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  update?: Prisma.StockJournalUpdateWithWhereUniqueWithoutCreatorInput | Prisma.StockJournalUpdateWithWhereUniqueWithoutCreatorInput[]
  updateMany?: Prisma.StockJournalUpdateManyWithWhereWithoutCreatorInput | Prisma.StockJournalUpdateManyWithWhereWithoutCreatorInput[]
  deleteMany?: Prisma.StockJournalScalarWhereInput | Prisma.StockJournalScalarWhereInput[]
}

export type StockJournalCreateNestedManyWithoutProductVariantInput = {
  create?: Prisma.XOR<Prisma.StockJournalCreateWithoutProductVariantInput, Prisma.StockJournalUncheckedCreateWithoutProductVariantInput> | Prisma.StockJournalCreateWithoutProductVariantInput[] | Prisma.StockJournalUncheckedCreateWithoutProductVariantInput[]
  connectOrCreate?: Prisma.StockJournalCreateOrConnectWithoutProductVariantInput | Prisma.StockJournalCreateOrConnectWithoutProductVariantInput[]
  createMany?: Prisma.StockJournalCreateManyProductVariantInputEnvelope
  connect?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
}

export type StockJournalUncheckedCreateNestedManyWithoutProductVariantInput = {
  create?: Prisma.XOR<Prisma.StockJournalCreateWithoutProductVariantInput, Prisma.StockJournalUncheckedCreateWithoutProductVariantInput> | Prisma.StockJournalCreateWithoutProductVariantInput[] | Prisma.StockJournalUncheckedCreateWithoutProductVariantInput[]
  connectOrCreate?: Prisma.StockJournalCreateOrConnectWithoutProductVariantInput | Prisma.StockJournalCreateOrConnectWithoutProductVariantInput[]
  createMany?: Prisma.StockJournalCreateManyProductVariantInputEnvelope
  connect?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
}

export type StockJournalUpdateManyWithoutProductVariantNestedInput = {
  create?: Prisma.XOR<Prisma.StockJournalCreateWithoutProductVariantInput, Prisma.StockJournalUncheckedCreateWithoutProductVariantInput> | Prisma.StockJournalCreateWithoutProductVariantInput[] | Prisma.StockJournalUncheckedCreateWithoutProductVariantInput[]
  connectOrCreate?: Prisma.StockJournalCreateOrConnectWithoutProductVariantInput | Prisma.StockJournalCreateOrConnectWithoutProductVariantInput[]
  upsert?: Prisma.StockJournalUpsertWithWhereUniqueWithoutProductVariantInput | Prisma.StockJournalUpsertWithWhereUniqueWithoutProductVariantInput[]
  createMany?: Prisma.StockJournalCreateManyProductVariantInputEnvelope
  set?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  disconnect?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  delete?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  connect?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  update?: Prisma.StockJournalUpdateWithWhereUniqueWithoutProductVariantInput | Prisma.StockJournalUpdateWithWhereUniqueWithoutProductVariantInput[]
  updateMany?: Prisma.StockJournalUpdateManyWithWhereWithoutProductVariantInput | Prisma.StockJournalUpdateManyWithWhereWithoutProductVariantInput[]
  deleteMany?: Prisma.StockJournalScalarWhereInput | Prisma.StockJournalScalarWhereInput[]
}

export type StockJournalUncheckedUpdateManyWithoutProductVariantNestedInput = {
  create?: Prisma.XOR<Prisma.StockJournalCreateWithoutProductVariantInput, Prisma.StockJournalUncheckedCreateWithoutProductVariantInput> | Prisma.StockJournalCreateWithoutProductVariantInput[] | Prisma.StockJournalUncheckedCreateWithoutProductVariantInput[]
  connectOrCreate?: Prisma.StockJournalCreateOrConnectWithoutProductVariantInput | Prisma.StockJournalCreateOrConnectWithoutProductVariantInput[]
  upsert?: Prisma.StockJournalUpsertWithWhereUniqueWithoutProductVariantInput | Prisma.StockJournalUpsertWithWhereUniqueWithoutProductVariantInput[]
  createMany?: Prisma.StockJournalCreateManyProductVariantInputEnvelope
  set?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  disconnect?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  delete?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  connect?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  update?: Prisma.StockJournalUpdateWithWhereUniqueWithoutProductVariantInput | Prisma.StockJournalUpdateWithWhereUniqueWithoutProductVariantInput[]
  updateMany?: Prisma.StockJournalUpdateManyWithWhereWithoutProductVariantInput | Prisma.StockJournalUpdateManyWithWhereWithoutProductVariantInput[]
  deleteMany?: Prisma.StockJournalScalarWhereInput | Prisma.StockJournalScalarWhereInput[]
}

export type StockJournalCreateNestedManyWithoutWarehouseInput = {
  create?: Prisma.XOR<Prisma.StockJournalCreateWithoutWarehouseInput, Prisma.StockJournalUncheckedCreateWithoutWarehouseInput> | Prisma.StockJournalCreateWithoutWarehouseInput[] | Prisma.StockJournalUncheckedCreateWithoutWarehouseInput[]
  connectOrCreate?: Prisma.StockJournalCreateOrConnectWithoutWarehouseInput | Prisma.StockJournalCreateOrConnectWithoutWarehouseInput[]
  createMany?: Prisma.StockJournalCreateManyWarehouseInputEnvelope
  connect?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
}

export type StockJournalUncheckedCreateNestedManyWithoutWarehouseInput = {
  create?: Prisma.XOR<Prisma.StockJournalCreateWithoutWarehouseInput, Prisma.StockJournalUncheckedCreateWithoutWarehouseInput> | Prisma.StockJournalCreateWithoutWarehouseInput[] | Prisma.StockJournalUncheckedCreateWithoutWarehouseInput[]
  connectOrCreate?: Prisma.StockJournalCreateOrConnectWithoutWarehouseInput | Prisma.StockJournalCreateOrConnectWithoutWarehouseInput[]
  createMany?: Prisma.StockJournalCreateManyWarehouseInputEnvelope
  connect?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
}

export type StockJournalUpdateManyWithoutWarehouseNestedInput = {
  create?: Prisma.XOR<Prisma.StockJournalCreateWithoutWarehouseInput, Prisma.StockJournalUncheckedCreateWithoutWarehouseInput> | Prisma.StockJournalCreateWithoutWarehouseInput[] | Prisma.StockJournalUncheckedCreateWithoutWarehouseInput[]
  connectOrCreate?: Prisma.StockJournalCreateOrConnectWithoutWarehouseInput | Prisma.StockJournalCreateOrConnectWithoutWarehouseInput[]
  upsert?: Prisma.StockJournalUpsertWithWhereUniqueWithoutWarehouseInput | Prisma.StockJournalUpsertWithWhereUniqueWithoutWarehouseInput[]
  createMany?: Prisma.StockJournalCreateManyWarehouseInputEnvelope
  set?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  disconnect?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  delete?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  connect?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  update?: Prisma.StockJournalUpdateWithWhereUniqueWithoutWarehouseInput | Prisma.StockJournalUpdateWithWhereUniqueWithoutWarehouseInput[]
  updateMany?: Prisma.StockJournalUpdateManyWithWhereWithoutWarehouseInput | Prisma.StockJournalUpdateManyWithWhereWithoutWarehouseInput[]
  deleteMany?: Prisma.StockJournalScalarWhereInput | Prisma.StockJournalScalarWhereInput[]
}

export type StockJournalUncheckedUpdateManyWithoutWarehouseNestedInput = {
  create?: Prisma.XOR<Prisma.StockJournalCreateWithoutWarehouseInput, Prisma.StockJournalUncheckedCreateWithoutWarehouseInput> | Prisma.StockJournalCreateWithoutWarehouseInput[] | Prisma.StockJournalUncheckedCreateWithoutWarehouseInput[]
  connectOrCreate?: Prisma.StockJournalCreateOrConnectWithoutWarehouseInput | Prisma.StockJournalCreateOrConnectWithoutWarehouseInput[]
  upsert?: Prisma.StockJournalUpsertWithWhereUniqueWithoutWarehouseInput | Prisma.StockJournalUpsertWithWhereUniqueWithoutWarehouseInput[]
  createMany?: Prisma.StockJournalCreateManyWarehouseInputEnvelope
  set?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  disconnect?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  delete?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  connect?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  update?: Prisma.StockJournalUpdateWithWhereUniqueWithoutWarehouseInput | Prisma.StockJournalUpdateWithWhereUniqueWithoutWarehouseInput[]
  updateMany?: Prisma.StockJournalUpdateManyWithWhereWithoutWarehouseInput | Prisma.StockJournalUpdateManyWithWhereWithoutWarehouseInput[]
  deleteMany?: Prisma.StockJournalScalarWhereInput | Prisma.StockJournalScalarWhereInput[]
}

export type EnumStockJournalTypeFieldUpdateOperationsInput = {
  set?: $Enums.StockJournalType
}

export type StockJournalCreateNestedManyWithoutOrderInput = {
  create?: Prisma.XOR<Prisma.StockJournalCreateWithoutOrderInput, Prisma.StockJournalUncheckedCreateWithoutOrderInput> | Prisma.StockJournalCreateWithoutOrderInput[] | Prisma.StockJournalUncheckedCreateWithoutOrderInput[]
  connectOrCreate?: Prisma.StockJournalCreateOrConnectWithoutOrderInput | Prisma.StockJournalCreateOrConnectWithoutOrderInput[]
  createMany?: Prisma.StockJournalCreateManyOrderInputEnvelope
  connect?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
}

export type StockJournalUncheckedCreateNestedManyWithoutOrderInput = {
  create?: Prisma.XOR<Prisma.StockJournalCreateWithoutOrderInput, Prisma.StockJournalUncheckedCreateWithoutOrderInput> | Prisma.StockJournalCreateWithoutOrderInput[] | Prisma.StockJournalUncheckedCreateWithoutOrderInput[]
  connectOrCreate?: Prisma.StockJournalCreateOrConnectWithoutOrderInput | Prisma.StockJournalCreateOrConnectWithoutOrderInput[]
  createMany?: Prisma.StockJournalCreateManyOrderInputEnvelope
  connect?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
}

export type StockJournalUpdateManyWithoutOrderNestedInput = {
  create?: Prisma.XOR<Prisma.StockJournalCreateWithoutOrderInput, Prisma.StockJournalUncheckedCreateWithoutOrderInput> | Prisma.StockJournalCreateWithoutOrderInput[] | Prisma.StockJournalUncheckedCreateWithoutOrderInput[]
  connectOrCreate?: Prisma.StockJournalCreateOrConnectWithoutOrderInput | Prisma.StockJournalCreateOrConnectWithoutOrderInput[]
  upsert?: Prisma.StockJournalUpsertWithWhereUniqueWithoutOrderInput | Prisma.StockJournalUpsertWithWhereUniqueWithoutOrderInput[]
  createMany?: Prisma.StockJournalCreateManyOrderInputEnvelope
  set?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  disconnect?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  delete?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  connect?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  update?: Prisma.StockJournalUpdateWithWhereUniqueWithoutOrderInput | Prisma.StockJournalUpdateWithWhereUniqueWithoutOrderInput[]
  updateMany?: Prisma.StockJournalUpdateManyWithWhereWithoutOrderInput | Prisma.StockJournalUpdateManyWithWhereWithoutOrderInput[]
  deleteMany?: Prisma.StockJournalScalarWhereInput | Prisma.StockJournalScalarWhereInput[]
}

export type StockJournalUncheckedUpdateManyWithoutOrderNestedInput = {
  create?: Prisma.XOR<Prisma.StockJournalCreateWithoutOrderInput, Prisma.StockJournalUncheckedCreateWithoutOrderInput> | Prisma.StockJournalCreateWithoutOrderInput[] | Prisma.StockJournalUncheckedCreateWithoutOrderInput[]
  connectOrCreate?: Prisma.StockJournalCreateOrConnectWithoutOrderInput | Prisma.StockJournalCreateOrConnectWithoutOrderInput[]
  upsert?: Prisma.StockJournalUpsertWithWhereUniqueWithoutOrderInput | Prisma.StockJournalUpsertWithWhereUniqueWithoutOrderInput[]
  createMany?: Prisma.StockJournalCreateManyOrderInputEnvelope
  set?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  disconnect?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  delete?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  connect?: Prisma.StockJournalWhereUniqueInput | Prisma.StockJournalWhereUniqueInput[]
  update?: Prisma.StockJournalUpdateWithWhereUniqueWithoutOrderInput | Prisma.StockJournalUpdateWithWhereUniqueWithoutOrderInput[]
  updateMany?: Prisma.StockJournalUpdateManyWithWhereWithoutOrderInput | Prisma.StockJournalUpdateManyWithWhereWithoutOrderInput[]
  deleteMany?: Prisma.StockJournalScalarWhereInput | Prisma.StockJournalScalarWhereInput[]
}

export type StockJournalCreateWithoutCreatorInput = {
  id?: string
  type: $Enums.StockJournalType
  quantity: number
  stockBefore: number
  stockAfter: number
  referenceNo: string
  reason: string
  notes?: string | null
  createdAt?: Date | string
  productVariant: Prisma.ProductVariantCreateNestedOneWithoutStockJournalsInput
  warehouse: Prisma.WarehouseCreateNestedOneWithoutStockJournalsInput
  order?: Prisma.OrderCreateNestedOneWithoutStockJournalsInput
}

export type StockJournalUncheckedCreateWithoutCreatorInput = {
  id?: string
  productVariantId: string
  warehouseId: string
  type: $Enums.StockJournalType
  quantity: number
  stockBefore: number
  stockAfter: number
  referenceNo: string
  reason: string
  notes?: string | null
  relatedOrderId?: string | null
  createdAt?: Date | string
}

export type StockJournalCreateOrConnectWithoutCreatorInput = {
  where: Prisma.StockJournalWhereUniqueInput
  create: Prisma.XOR<Prisma.StockJournalCreateWithoutCreatorInput, Prisma.StockJournalUncheckedCreateWithoutCreatorInput>
}

export type StockJournalCreateManyCreatorInputEnvelope = {
  data: Prisma.StockJournalCreateManyCreatorInput | Prisma.StockJournalCreateManyCreatorInput[]
  skipDuplicates?: boolean
}

export type StockJournalUpsertWithWhereUniqueWithoutCreatorInput = {
  where: Prisma.StockJournalWhereUniqueInput
  update: Prisma.XOR<Prisma.StockJournalUpdateWithoutCreatorInput, Prisma.StockJournalUncheckedUpdateWithoutCreatorInput>
  create: Prisma.XOR<Prisma.StockJournalCreateWithoutCreatorInput, Prisma.StockJournalUncheckedCreateWithoutCreatorInput>
}

export type StockJournalUpdateWithWhereUniqueWithoutCreatorInput = {
  where: Prisma.StockJournalWhereUniqueInput
  data: Prisma.XOR<Prisma.StockJournalUpdateWithoutCreatorInput, Prisma.StockJournalUncheckedUpdateWithoutCreatorInput>
}

export type StockJournalUpdateManyWithWhereWithoutCreatorInput = {
  where: Prisma.StockJournalScalarWhereInput
  data: Prisma.XOR<Prisma.StockJournalUpdateManyMutationInput, Prisma.StockJournalUncheckedUpdateManyWithoutCreatorInput>
}

export type StockJournalScalarWhereInput = {
  AND?: Prisma.StockJournalScalarWhereInput | Prisma.StockJournalScalarWhereInput[]
  OR?: Prisma.StockJournalScalarWhereInput[]
  NOT?: Prisma.StockJournalScalarWhereInput | Prisma.StockJournalScalarWhereInput[]
  id?: Prisma.StringFilter<"StockJournal"> | string
  productVariantId?: Prisma.StringFilter<"StockJournal"> | string
  warehouseId?: Prisma.StringFilter<"StockJournal"> | string
  type?: Prisma.EnumStockJournalTypeFilter<"StockJournal"> | $Enums.StockJournalType
  quantity?: Prisma.IntFilter<"StockJournal"> | number
  stockBefore?: Prisma.IntFilter<"StockJournal"> | number
  stockAfter?: Prisma.IntFilter<"StockJournal"> | number
  referenceNo?: Prisma.StringFilter<"StockJournal"> | string
  reason?: Prisma.StringFilter<"StockJournal"> | string
  notes?: Prisma.StringNullableFilter<"StockJournal"> | string | null
  relatedOrderId?: Prisma.StringNullableFilter<"StockJournal"> | string | null
  createdBy?: Prisma.StringFilter<"StockJournal"> | string
  createdAt?: Prisma.DateTimeFilter<"StockJournal"> | Date | string
}

export type StockJournalCreateWithoutProductVariantInput = {
  id?: string
  type: $Enums.StockJournalType
  quantity: number
  stockBefore: number
  stockAfter: number
  referenceNo: string
  reason: string
  notes?: string | null
  createdAt?: Date | string
  warehouse: Prisma.WarehouseCreateNestedOneWithoutStockJournalsInput
  creator: Prisma.UserCreateNestedOneWithoutStockJournalsInput
  order?: Prisma.OrderCreateNestedOneWithoutStockJournalsInput
}

export type StockJournalUncheckedCreateWithoutProductVariantInput = {
  id?: string
  warehouseId: string
  type: $Enums.StockJournalType
  quantity: number
  stockBefore: number
  stockAfter: number
  referenceNo: string
  reason: string
  notes?: string | null
  relatedOrderId?: string | null
  createdBy: string
  createdAt?: Date | string
}

export type StockJournalCreateOrConnectWithoutProductVariantInput = {
  where: Prisma.StockJournalWhereUniqueInput
  create: Prisma.XOR<Prisma.StockJournalCreateWithoutProductVariantInput, Prisma.StockJournalUncheckedCreateWithoutProductVariantInput>
}

export type StockJournalCreateManyProductVariantInputEnvelope = {
  data: Prisma.StockJournalCreateManyProductVariantInput | Prisma.StockJournalCreateManyProductVariantInput[]
  skipDuplicates?: boolean
}

export type StockJournalUpsertWithWhereUniqueWithoutProductVariantInput = {
  where: Prisma.StockJournalWhereUniqueInput
  update: Prisma.XOR<Prisma.StockJournalUpdateWithoutProductVariantInput, Prisma.StockJournalUncheckedUpdateWithoutProductVariantInput>
  create: Prisma.XOR<Prisma.StockJournalCreateWithoutProductVariantInput, Prisma.StockJournalUncheckedCreateWithoutProductVariantInput>
}

export type StockJournalUpdateWithWhereUniqueWithoutProductVariantInput = {
  where: Prisma.StockJournalWhereUniqueInput
  data: Prisma.XOR<Prisma.StockJournalUpdateWithoutProductVariantInput, Prisma.StockJournalUncheckedUpdateWithoutProductVariantInput>
}

export type StockJournalUpdateManyWithWhereWithoutProductVariantInput = {
  where: Prisma.StockJournalScalarWhereInput
  data: Prisma.XOR<Prisma.StockJournalUpdateManyMutationInput, Prisma.StockJournalUncheckedUpdateManyWithoutProductVariantInput>
}

export type StockJournalCreateWithoutWarehouseInput = {
  id?: string
  type: $Enums.StockJournalType
  quantity: number
  stockBefore: number
  stockAfter: number
  referenceNo: string
  reason: string
  notes?: string | null
  createdAt?: Date | string
  productVariant: Prisma.ProductVariantCreateNestedOneWithoutStockJournalsInput
  creator: Prisma.UserCreateNestedOneWithoutStockJournalsInput
  order?: Prisma.OrderCreateNestedOneWithoutStockJournalsInput
}

export type StockJournalUncheckedCreateWithoutWarehouseInput = {
  id?: string
  productVariantId: string
  type: $Enums.StockJournalType
  quantity: number
  stockBefore: number
  stockAfter: number
  referenceNo: string
  reason: string
  notes?: string | null
  relatedOrderId?: string | null
  createdBy: string
  createdAt?: Date | string
}

export type StockJournalCreateOrConnectWithoutWarehouseInput = {
  where: Prisma.StockJournalWhereUniqueInput
  create: Prisma.XOR<Prisma.StockJournalCreateWithoutWarehouseInput, Prisma.StockJournalUncheckedCreateWithoutWarehouseInput>
}

export type StockJournalCreateManyWarehouseInputEnvelope = {
  data: Prisma.StockJournalCreateManyWarehouseInput | Prisma.StockJournalCreateManyWarehouseInput[]
  skipDuplicates?: boolean
}

export type StockJournalUpsertWithWhereUniqueWithoutWarehouseInput = {
  where: Prisma.StockJournalWhereUniqueInput
  update: Prisma.XOR<Prisma.StockJournalUpdateWithoutWarehouseInput, Prisma.StockJournalUncheckedUpdateWithoutWarehouseInput>
  create: Prisma.XOR<Prisma.StockJournalCreateWithoutWarehouseInput, Prisma.StockJournalUncheckedCreateWithoutWarehouseInput>
}

export type StockJournalUpdateWithWhereUniqueWithoutWarehouseInput = {
  where: Prisma.StockJournalWhereUniqueInput
  data: Prisma.XOR<Prisma.StockJournalUpdateWithoutWarehouseInput, Prisma.StockJournalUncheckedUpdateWithoutWarehouseInput>
}

export type StockJournalUpdateManyWithWhereWithoutWarehouseInput = {
  where: Prisma.StockJournalScalarWhereInput
  data: Prisma.XOR<Prisma.StockJournalUpdateManyMutationInput, Prisma.StockJournalUncheckedUpdateManyWithoutWarehouseInput>
}

export type StockJournalCreateWithoutOrderInput = {
  id?: string
  type: $Enums.StockJournalType
  quantity: number
  stockBefore: number
  stockAfter: number
  referenceNo: string
  reason: string
  notes?: string | null
  createdAt?: Date | string
  productVariant: Prisma.ProductVariantCreateNestedOneWithoutStockJournalsInput
  warehouse: Prisma.WarehouseCreateNestedOneWithoutStockJournalsInput
  creator: Prisma.UserCreateNestedOneWithoutStockJournalsInput
}

export type StockJournalUncheckedCreateWithoutOrderInput = {
  id?: string
  productVariantId: string
  warehouseId: string
  type: $Enums.StockJournalType
  quantity: number
  stockBefore: number
  stockAfter: number
  referenceNo: string
  reason: string
  notes?: string | null
  createdBy: string
  createdAt?: Date | string
}

export type StockJournalCreateOrConnectWithoutOrderInput = {
  where: Prisma.StockJournalWhereUniqueInput
  create: Prisma.XOR<Prisma.StockJournalCreateWithoutOrderInput, Prisma.StockJournalUncheckedCreateWithoutOrderInput>
}

export type StockJournalCreateManyOrderInputEnvelope = {
  data: Prisma.StockJournalCreateManyOrderInput | Prisma.StockJournalCreateManyOrderInput[]
  skipDuplicates?: boolean
}

export type StockJournalUpsertWithWhereUniqueWithoutOrderInput = {
  where: Prisma.StockJournalWhereUniqueInput
  update: Prisma.XOR<Prisma.StockJournalUpdateWithoutOrderInput, Prisma.StockJournalUncheckedUpdateWithoutOrderInput>
  create: Prisma.XOR<Prisma.StockJournalCreateWithoutOrderInput, Prisma.StockJournalUncheckedCreateWithoutOrderInput>
}

export type StockJournalUpdateWithWhereUniqueWithoutOrderInput = {
  where: Prisma.StockJournalWhereUniqueInput
  data: Prisma.XOR<Prisma.StockJournalUpdateWithoutOrderInput, Prisma.StockJournalUncheckedUpdateWithoutOrderInput>
}

export type StockJournalUpdateManyWithWhereWithoutOrderInput = {
  where: Prisma.StockJournalScalarWhereInput
  data: Prisma.XOR<Prisma.StockJournalUpdateManyMutationInput, Prisma.StockJournalUncheckedUpdateManyWithoutOrderInput>
}

export type StockJournalCreateManyCreatorInput = {
  id?: string
  productVariantId: string
  warehouseId: string
  type: $Enums.StockJournalType
  quantity: number
  stockBefore: number
  stockAfter: number
  referenceNo: string
  reason: string
  notes?: string | null
  relatedOrderId?: string | null
  createdAt?: Date | string
}

export type StockJournalUpdateWithoutCreatorInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumStockJournalTypeFieldUpdateOperationsInput | $Enums.StockJournalType
  quantity?: Prisma.IntFieldUpdateOperationsInput | number
  stockBefore?: Prisma.IntFieldUpdateOperationsInput | number
  stockAfter?: Prisma.IntFieldUpdateOperationsInput | number
  referenceNo?: Prisma.StringFieldUpdateOperationsInput | string
  reason?: Prisma.StringFieldUpdateOperationsInput | string
  notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  productVariant?: Prisma.ProductVariantUpdateOneRequiredWithoutStockJournalsNestedInput
  warehouse?: Prisma.WarehouseUpdateOneRequiredWithoutStockJournalsNestedInput
  order?: Prisma.OrderUpdateOneWithoutStockJournalsNestedInput
}

export type StockJournalUncheckedUpdateWithoutCreatorInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  productVariantId?: Prisma.StringFieldUpdateOperationsInput | string
  warehouseId?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumStockJournalTypeFieldUpdateOperationsInput | $Enums.StockJournalType
  quantity?: Prisma.IntFieldUpdateOperationsInput | number
  stockBefore?: Prisma.IntFieldUpdateOperationsInput | number
  stockAfter?: Prisma.IntFieldUpdateOperationsInput | number
  referenceNo?: Prisma.StringFieldUpdateOperationsInput | string
  reason?: Prisma.StringFieldUpdateOperationsInput | string
  notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  relatedOrderId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type StockJournalUncheckedUpdateManyWithoutCreatorInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  productVariantId?: Prisma.StringFieldUpdateOperationsInput | string
  warehouseId?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumStockJournalTypeFieldUpdateOperationsInput | $Enums.StockJournalType
  quantity?: Prisma.IntFieldUpdateOperationsInput | number
  stockBefore?: Prisma.IntFieldUpdateOperationsInput | number
  stockAfter?: Prisma.IntFieldUpdateOperationsInput | number
  referenceNo?: Prisma.StringFieldUpdateOperationsInput | string
  reason?: Prisma.StringFieldUpdateOperationsInput | string
  notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  relatedOrderId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type StockJournalCreateManyProductVariantInput = {
  id?: string
  warehouseId: string
  type: $Enums.StockJournalType
  quantity: number
  stockBefore: number
  stockAfter: number
  referenceNo: string
  reason: string
  notes?: string | null
  relatedOrderId?: string | null
  createdBy: string
  createdAt?: Date | string
}

export type StockJournalUpdateWithoutProductVariantInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumStockJournalTypeFieldUpdateOperationsInput | $Enums.StockJournalType
  quantity?: Prisma.IntFieldUpdateOperationsInput | number
  stockBefore?: Prisma.IntFieldUpdateOperationsInput | number
  stockAfter?: Prisma.IntFieldUpdateOperationsInput | number
  referenceNo?: Prisma.StringFieldUpdateOperationsInput | string
  reason?: Prisma.StringFieldUpdateOperationsInput | string
  notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  warehouse?: Prisma.WarehouseUpdateOneRequiredWithoutStockJournalsNestedInput
  creator?: Prisma.UserUpdateOneRequiredWithoutStockJournalsNestedInput
  order?: Prisma.OrderUpdateOneWithoutStockJournalsNestedInput
}

export type StockJournalUncheckedUpdateWithoutProductVariantInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  warehouseId?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumStockJournalTypeFieldUpdateOperationsInput | $Enums.StockJournalType
  quantity?: Prisma.IntFieldUpdateOperationsInput | number
  stockBefore?: Prisma.IntFieldUpdateOperationsInput | number
  stockAfter?: Prisma.IntFieldUpdateOperationsInput | number
  referenceNo?: Prisma.StringFieldUpdateOperationsInput | string
  reason?: Prisma.StringFieldUpdateOperationsInput | string
  notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  relatedOrderId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdBy?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type StockJournalUncheckedUpdateManyWithoutProductVariantInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  warehouseId?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumStockJournalTypeFieldUpdateOperationsInput | $Enums.StockJournalType
  quantity?: Prisma.IntFieldUpdateOperationsInput | number
  stockBefore?: Prisma.IntFieldUpdateOperationsInput | number
  stockAfter?: Prisma.IntFieldUpdateOperationsInput | number
  referenceNo?: Prisma.StringFieldUpdateOperationsInput | string
  reason?: Prisma.StringFieldUpdateOperationsInput | string
  notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  relatedOrderId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdBy?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type StockJournalCreateManyWarehouseInput = {
  id?: string
  productVariantId: string
  type: $Enums.StockJournalType
  quantity: number
  stockBefore: number
  stockAfter: number
  referenceNo: string
  reason: string
  notes?: string | null
  relatedOrderId?: string | null
  createdBy: string
  createdAt?: Date | string
}

export type StockJournalUpdateWithoutWarehouseInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumStockJournalTypeFieldUpdateOperationsInput | $Enums.StockJournalType
  quantity?: Prisma.IntFieldUpdateOperationsInput | number
  stockBefore?: Prisma.IntFieldUpdateOperationsInput | number
  stockAfter?: Prisma.IntFieldUpdateOperationsInput | number
  referenceNo?: Prisma.StringFieldUpdateOperationsInput | string
  reason?: Prisma.StringFieldUpdateOperationsInput | string
  notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  productVariant?: Prisma.ProductVariantUpdateOneRequiredWithoutStockJournalsNestedInput
  creator?: Prisma.UserUpdateOneRequiredWithoutStockJournalsNestedInput
  order?: Prisma.OrderUpdateOneWithoutStockJournalsNestedInput
}

export type StockJournalUncheckedUpdateWithoutWarehouseInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  productVariantId?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumStockJournalTypeFieldUpdateOperationsInput | $Enums.StockJournalType
  quantity?: Prisma.IntFieldUpdateOperationsInput | number
  stockBefore?: Prisma.IntFieldUpdateOperationsInput | number
  stockAfter?: Prisma.IntFieldUpdateOperationsInput | number
  referenceNo?: Prisma.StringFieldUpdateOperationsInput | string
  reason?: Prisma.StringFieldUpdateOperationsInput | string
  notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  relatedOrderId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdBy?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type StockJournalUncheckedUpdateManyWithoutWarehouseInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  productVariantId?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumStockJournalTypeFieldUpdateOperationsInput | $Enums.StockJournalType
  quantity?: Prisma.IntFieldUpdateOperationsInput | number
  stockBefore?: Prisma.IntFieldUpdateOperationsInput | number
  stockAfter?: Prisma.IntFieldUpdateOperationsInput | number
  referenceNo?: Prisma.StringFieldUpdateOperationsInput | string
  reason?: Prisma.StringFieldUpdateOperationsInput | string
  notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  relatedOrderId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdBy?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type StockJournalCreateManyOrderInput = {
  id?: string
  productVariantId: string
  warehouseId: string
  type: $Enums.StockJournalType
  quantity: number
  stockBefore: number
  stockAfter: number
  referenceNo: string
  reason: string
  notes?: string | null
  createdBy: string
  createdAt?: Date | string
}

export type StockJournalUpdateWithoutOrderInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumStockJournalTypeFieldUpdateOperationsInput | $Enums.StockJournalType
  quantity?: Prisma.IntFieldUpdateOperationsInput | number
  stockBefore?: Prisma.IntFieldUpdateOperationsInput | number
  stockAfter?: Prisma.IntFieldUpdateOperationsInput | number
  referenceNo?: Prisma.StringFieldUpdateOperationsInput | string
  reason?: Prisma.StringFieldUpdateOperationsInput | string
  notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  productVariant?: Prisma.ProductVariantUpdateOneRequiredWithoutStockJournalsNestedInput
  warehouse?: Prisma.WarehouseUpdateOneRequiredWithoutStockJournalsNestedInput
  creator?: Prisma.UserUpdateOneRequiredWithoutStockJournalsNestedInput
}

export type StockJournalUncheckedUpdateWithoutOrderInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  productVariantId?: Prisma.StringFieldUpdateOperationsInput | string
  warehouseId?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumStockJournalTypeFieldUpdateOperationsInput | $Enums.StockJournalType
  quantity?: Prisma.IntFieldUpdateOperationsInput | number
  stockBefore?: Prisma.IntFieldUpdateOperationsInput | number
  stockAfter?: Prisma.IntFieldUpdateOperationsInput | number
  referenceNo?: Prisma.StringFieldUpdateOperationsInput | string
  reason?: Prisma.StringFieldUpdateOperationsInput | string
  notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdBy?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type StockJournalUncheckedUpdateManyWithoutOrderInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  productVariantId?: Prisma.StringFieldUpdateOperationsInput | string
  warehouseId?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.EnumStockJournalTypeFieldUpdateOperationsInput | $Enums.StockJournalType
  quantity?: Prisma.IntFieldUpdateOperationsInput | number
  stockBefore?: Prisma.IntFieldUpdateOperationsInput | number
  stockAfter?: Prisma.IntFieldUpdateOperationsInput | number
  referenceNo?: Prisma.StringFieldUpdateOperationsInput | string
  reason?: Prisma.StringFieldUpdateOperationsInput | string
  notes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdBy?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type StockJournalSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  productVariantId?: boolean
  warehouseId?: boolean
  type?: boolean
  quantity?: boolean
  stockBefore?: boolean
  stockAfter?: boolean
  referenceNo?: boolean
  reason?: boolean
  notes?: boolean
  relatedOrderId?: boolean
  createdBy?: boolean
  createdAt?: boolean
  productVariant?: boolean | Prisma.ProductVariantDefaultArgs<ExtArgs>
  warehouse?: boolean | Prisma.WarehouseDefaultArgs<ExtArgs>
  creator?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  order?: boolean | Prisma.StockJournal$orderArgs<ExtArgs>
}, ExtArgs["result"]["stockJournal"]>

export type StockJournalSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  productVariantId?: boolean
  warehouseId?: boolean
  type?: boolean
  quantity?: boolean
  stockBefore?: boolean
  stockAfter?: boolean
  referenceNo?: boolean
  reason?: boolean
  notes?: boolean
  relatedOrderId?: boolean
  createdBy?: boolean
  createdAt?: boolean
  productVariant?: boolean | Prisma.ProductVariantDefaultArgs<ExtArgs>
  warehouse?: boolean | Prisma.WarehouseDefaultArgs<ExtArgs>
  creator?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  order?: boolean | Prisma.StockJournal$orderArgs<ExtArgs>
}, ExtArgs["result"]["stockJournal"]>

export type StockJournalSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  productVariantId?: boolean
  warehouseId?: boolean
  type?: boolean
  quantity?: boolean
  stockBefore?: boolean
  stockAfter?: boolean
  referenceNo?: boolean
  reason?: boolean
  notes?: boolean
  relatedOrderId?: boolean
  createdBy?: boolean
  createdAt?: boolean
  productVariant?: boolean | Prisma.ProductVariantDefaultArgs<ExtArgs>
  warehouse?: boolean | Prisma.WarehouseDefaultArgs<ExtArgs>
  creator?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  order?: boolean | Prisma.StockJournal$orderArgs<ExtArgs>
}, ExtArgs["result"]["stockJournal"]>

export type StockJournalSelectScalar = {
  id?: boolean
  productVariantId?: boolean
  warehouseId?: boolean
  type?: boolean
  quantity?: boolean
  stockBefore?: boolean
  stockAfter?: boolean
  referenceNo?: boolean
  reason?: boolean
  notes?: boolean
  relatedOrderId?: boolean
  createdBy?: boolean
  createdAt?: boolean
}

export type StockJournalOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "productVariantId" | "warehouseId" | "type" | "quantity" | "stockBefore" | "stockAfter" | "referenceNo" | "reason" | "notes" | "relatedOrderId" | "createdBy" | "createdAt", ExtArgs["result"]["stockJournal"]>
export type StockJournalInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  productVariant?: boolean | Prisma.ProductVariantDefaultArgs<ExtArgs>
  warehouse?: boolean | Prisma.WarehouseDefaultArgs<ExtArgs>
  creator?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  order?: boolean | Prisma.StockJournal$orderArgs<ExtArgs>
}
export type StockJournalIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  productVariant?: boolean | Prisma.ProductVariantDefaultArgs<ExtArgs>
  warehouse?: boolean | Prisma.WarehouseDefaultArgs<ExtArgs>
  creator?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  order?: boolean | Prisma.StockJournal$orderArgs<ExtArgs>
}
export type StockJournalIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  productVariant?: boolean | Prisma.ProductVariantDefaultArgs<ExtArgs>
  warehouse?: boolean | Prisma.WarehouseDefaultArgs<ExtArgs>
  creator?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  order?: boolean | Prisma.StockJournal$orderArgs<ExtArgs>
}

export type $StockJournalPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "StockJournal"
  objects: {
    productVariant: Prisma.$ProductVariantPayload<ExtArgs>
    warehouse: Prisma.$WarehousePayload<ExtArgs>
    creator: Prisma.$UserPayload<ExtArgs>
    order: Prisma.$OrderPayload<ExtArgs> | null
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    productVariantId: string
    warehouseId: string
    type: $Enums.StockJournalType
    quantity: number
    stockBefore: number
    stockAfter: number
    referenceNo: string
    reason: string
    notes: string | null
    relatedOrderId: string | null
    createdBy: string
    createdAt: Date
  }, ExtArgs["result"]["stockJournal"]>
  composites: {}
}

export type StockJournalGetPayload<S extends boolean | null | undefined | StockJournalDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$StockJournalPayload, S>

export type StockJournalCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<StockJournalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: StockJournalCountAggregateInputType | true
  }

export interface StockJournalDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockJournal'], meta: { name: 'StockJournal' } }
  /**
   * Find zero or one StockJournal that matches the filter.
   * @param {StockJournalFindUniqueArgs} args - Arguments to find a StockJournal
   * @example
   * // Get one StockJournal
   * const stockJournal = await prisma.stockJournal.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends StockJournalFindUniqueArgs>(args: Prisma.SelectSubset<T, StockJournalFindUniqueArgs<ExtArgs>>): Prisma.Prisma__StockJournalClient<runtime.Types.Result.GetResult<Prisma.$StockJournalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one StockJournal that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {StockJournalFindUniqueOrThrowArgs} args - Arguments to find a StockJournal
   * @example
   * // Get one StockJournal
   * const stockJournal = await prisma.stockJournal.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends StockJournalFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, StockJournalFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__StockJournalClient<runtime.Types.Result.GetResult<Prisma.$StockJournalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first StockJournal that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {StockJournalFindFirstArgs} args - Arguments to find a StockJournal
   * @example
   * // Get one StockJournal
   * const stockJournal = await prisma.stockJournal.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends StockJournalFindFirstArgs>(args?: Prisma.SelectSubset<T, StockJournalFindFirstArgs<ExtArgs>>): Prisma.Prisma__StockJournalClient<runtime.Types.Result.GetResult<Prisma.$StockJournalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first StockJournal that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {StockJournalFindFirstOrThrowArgs} args - Arguments to find a StockJournal
   * @example
   * // Get one StockJournal
   * const stockJournal = await prisma.stockJournal.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends StockJournalFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, StockJournalFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__StockJournalClient<runtime.Types.Result.GetResult<Prisma.$StockJournalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more StockJournals that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {StockJournalFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all StockJournals
   * const stockJournals = await prisma.stockJournal.findMany()
   * 
   * // Get first 10 StockJournals
   * const stockJournals = await prisma.stockJournal.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const stockJournalWithIdOnly = await prisma.stockJournal.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends StockJournalFindManyArgs>(args?: Prisma.SelectSubset<T, StockJournalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$StockJournalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a StockJournal.
   * @param {StockJournalCreateArgs} args - Arguments to create a StockJournal.
   * @example
   * // Create one StockJournal
   * const StockJournal = await prisma.stockJournal.create({
   *   data: {
   *     // ... data to create a StockJournal
   *   }
   * })
   * 
   */
  create<T extends StockJournalCreateArgs>(args: Prisma.SelectSubset<T, StockJournalCreateArgs<ExtArgs>>): Prisma.Prisma__StockJournalClient<runtime.Types.Result.GetResult<Prisma.$StockJournalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many StockJournals.
   * @param {StockJournalCreateManyArgs} args - Arguments to create many StockJournals.
   * @example
   * // Create many StockJournals
   * const stockJournal = await prisma.stockJournal.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends StockJournalCreateManyArgs>(args?: Prisma.SelectSubset<T, StockJournalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many StockJournals and returns the data saved in the database.
   * @param {StockJournalCreateManyAndReturnArgs} args - Arguments to create many StockJournals.
   * @example
   * // Create many StockJournals
   * const stockJournal = await prisma.stockJournal.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many StockJournals and only return the `id`
   * const stockJournalWithIdOnly = await prisma.stockJournal.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends StockJournalCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, StockJournalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$StockJournalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a StockJournal.
   * @param {StockJournalDeleteArgs} args - Arguments to delete one StockJournal.
   * @example
   * // Delete one StockJournal
   * const StockJournal = await prisma.stockJournal.delete({
   *   where: {
   *     // ... filter to delete one StockJournal
   *   }
   * })
   * 
   */
  delete<T extends StockJournalDeleteArgs>(args: Prisma.SelectSubset<T, StockJournalDeleteArgs<ExtArgs>>): Prisma.Prisma__StockJournalClient<runtime.Types.Result.GetResult<Prisma.$StockJournalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one StockJournal.
   * @param {StockJournalUpdateArgs} args - Arguments to update one StockJournal.
   * @example
   * // Update one StockJournal
   * const stockJournal = await prisma.stockJournal.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends StockJournalUpdateArgs>(args: Prisma.SelectSubset<T, StockJournalUpdateArgs<ExtArgs>>): Prisma.Prisma__StockJournalClient<runtime.Types.Result.GetResult<Prisma.$StockJournalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more StockJournals.
   * @param {StockJournalDeleteManyArgs} args - Arguments to filter StockJournals to delete.
   * @example
   * // Delete a few StockJournals
   * const { count } = await prisma.stockJournal.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends StockJournalDeleteManyArgs>(args?: Prisma.SelectSubset<T, StockJournalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more StockJournals.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {StockJournalUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many StockJournals
   * const stockJournal = await prisma.stockJournal.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends StockJournalUpdateManyArgs>(args: Prisma.SelectSubset<T, StockJournalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more StockJournals and returns the data updated in the database.
   * @param {StockJournalUpdateManyAndReturnArgs} args - Arguments to update many StockJournals.
   * @example
   * // Update many StockJournals
   * const stockJournal = await prisma.stockJournal.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more StockJournals and only return the `id`
   * const stockJournalWithIdOnly = await prisma.stockJournal.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends StockJournalUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, StockJournalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$StockJournalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one StockJournal.
   * @param {StockJournalUpsertArgs} args - Arguments to update or create a StockJournal.
   * @example
   * // Update or create a StockJournal
   * const stockJournal = await prisma.stockJournal.upsert({
   *   create: {
   *     // ... data to create a StockJournal
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the StockJournal we want to update
   *   }
   * })
   */
  upsert<T extends StockJournalUpsertArgs>(args: Prisma.SelectSubset<T, StockJournalUpsertArgs<ExtArgs>>): Prisma.Prisma__StockJournalClient<runtime.Types.Result.GetResult<Prisma.$StockJournalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of StockJournals.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {StockJournalCountArgs} args - Arguments to filter StockJournals to count.
   * @example
   * // Count the number of StockJournals
   * const count = await prisma.stockJournal.count({
   *   where: {
   *     // ... the filter for the StockJournals we want to count
   *   }
   * })
  **/
  count<T extends StockJournalCountArgs>(
    args?: Prisma.Subset<T, StockJournalCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], StockJournalCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a StockJournal.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {StockJournalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends StockJournalAggregateArgs>(args: Prisma.Subset<T, StockJournalAggregateArgs>): Prisma.PrismaPromise<GetStockJournalAggregateType<T>>

  /**
   * Group by StockJournal.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {StockJournalGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends StockJournalGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: StockJournalGroupByArgs['orderBy'] }
      : { orderBy?: StockJournalGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, StockJournalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockJournalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the StockJournal model
 */
readonly fields: StockJournalFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for StockJournal.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__StockJournalClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  productVariant<T extends Prisma.ProductVariantDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ProductVariantDefaultArgs<ExtArgs>>): Prisma.Prisma__ProductVariantClient<runtime.Types.Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  warehouse<T extends Prisma.WarehouseDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.WarehouseDefaultArgs<ExtArgs>>): Prisma.Prisma__WarehouseClient<runtime.Types.Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  creator<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  order<T extends Prisma.StockJournal$orderArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.StockJournal$orderArgs<ExtArgs>>): Prisma.Prisma__OrderClient<runtime.Types.Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the StockJournal model
 */
export interface StockJournalFieldRefs {
  readonly id: Prisma.FieldRef<"StockJournal", 'String'>
  readonly productVariantId: Prisma.FieldRef<"StockJournal", 'String'>
  readonly warehouseId: Prisma.FieldRef<"StockJournal", 'String'>
  readonly type: Prisma.FieldRef<"StockJournal", 'StockJournalType'>
  readonly quantity: Prisma.FieldRef<"StockJournal", 'Int'>
  readonly stockBefore: Prisma.FieldRef<"StockJournal", 'Int'>
  readonly stockAfter: Prisma.FieldRef<"StockJournal", 'Int'>
  readonly referenceNo: Prisma.FieldRef<"StockJournal", 'String'>
  readonly reason: Prisma.FieldRef<"StockJournal", 'String'>
  readonly notes: Prisma.FieldRef<"StockJournal", 'String'>
  readonly relatedOrderId: Prisma.FieldRef<"StockJournal", 'String'>
  readonly createdBy: Prisma.FieldRef<"StockJournal", 'String'>
  readonly createdAt: Prisma.FieldRef<"StockJournal", 'DateTime'>
}
    

// Custom InputTypes
/**
 * StockJournal findUnique
 */
export type StockJournalFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StockJournal
   */
  select?: Prisma.StockJournalSelect<ExtArgs> | null
  /**
   * Omit specific fields from the StockJournal
   */
  omit?: Prisma.StockJournalOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StockJournalInclude<ExtArgs> | null
  /**
   * Filter, which StockJournal to fetch.
   */
  where: Prisma.StockJournalWhereUniqueInput
}

/**
 * StockJournal findUniqueOrThrow
 */
export type StockJournalFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StockJournal
   */
  select?: Prisma.StockJournalSelect<ExtArgs> | null
  /**
   * Omit specific fields from the StockJournal
   */
  omit?: Prisma.StockJournalOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StockJournalInclude<ExtArgs> | null
  /**
   * Filter, which StockJournal to fetch.
   */
  where: Prisma.StockJournalWhereUniqueInput
}

/**
 * StockJournal findFirst
 */
export type StockJournalFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StockJournal
   */
  select?: Prisma.StockJournalSelect<ExtArgs> | null
  /**
   * Omit specific fields from the StockJournal
   */
  omit?: Prisma.StockJournalOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StockJournalInclude<ExtArgs> | null
  /**
   * Filter, which StockJournal to fetch.
   */
  where?: Prisma.StockJournalWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of StockJournals to fetch.
   */
  orderBy?: Prisma.StockJournalOrderByWithRelationInput | Prisma.StockJournalOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for StockJournals.
   */
  cursor?: Prisma.StockJournalWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` StockJournals from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` StockJournals.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of StockJournals.
   */
  distinct?: Prisma.StockJournalScalarFieldEnum | Prisma.StockJournalScalarFieldEnum[]
}

/**
 * StockJournal findFirstOrThrow
 */
export type StockJournalFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StockJournal
   */
  select?: Prisma.StockJournalSelect<ExtArgs> | null
  /**
   * Omit specific fields from the StockJournal
   */
  omit?: Prisma.StockJournalOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StockJournalInclude<ExtArgs> | null
  /**
   * Filter, which StockJournal to fetch.
   */
  where?: Prisma.StockJournalWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of StockJournals to fetch.
   */
  orderBy?: Prisma.StockJournalOrderByWithRelationInput | Prisma.StockJournalOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for StockJournals.
   */
  cursor?: Prisma.StockJournalWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` StockJournals from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` StockJournals.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of StockJournals.
   */
  distinct?: Prisma.StockJournalScalarFieldEnum | Prisma.StockJournalScalarFieldEnum[]
}

/**
 * StockJournal findMany
 */
export type StockJournalFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StockJournal
   */
  select?: Prisma.StockJournalSelect<ExtArgs> | null
  /**
   * Omit specific fields from the StockJournal
   */
  omit?: Prisma.StockJournalOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StockJournalInclude<ExtArgs> | null
  /**
   * Filter, which StockJournals to fetch.
   */
  where?: Prisma.StockJournalWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of StockJournals to fetch.
   */
  orderBy?: Prisma.StockJournalOrderByWithRelationInput | Prisma.StockJournalOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing StockJournals.
   */
  cursor?: Prisma.StockJournalWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` StockJournals from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` StockJournals.
   */
  skip?: number
  distinct?: Prisma.StockJournalScalarFieldEnum | Prisma.StockJournalScalarFieldEnum[]
}

/**
 * StockJournal create
 */
export type StockJournalCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StockJournal
   */
  select?: Prisma.StockJournalSelect<ExtArgs> | null
  /**
   * Omit specific fields from the StockJournal
   */
  omit?: Prisma.StockJournalOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StockJournalInclude<ExtArgs> | null
  /**
   * The data needed to create a StockJournal.
   */
  data: Prisma.XOR<Prisma.StockJournalCreateInput, Prisma.StockJournalUncheckedCreateInput>
}

/**
 * StockJournal createMany
 */
export type StockJournalCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many StockJournals.
   */
  data: Prisma.StockJournalCreateManyInput | Prisma.StockJournalCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * StockJournal createManyAndReturn
 */
export type StockJournalCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StockJournal
   */
  select?: Prisma.StockJournalSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the StockJournal
   */
  omit?: Prisma.StockJournalOmit<ExtArgs> | null
  /**
   * The data used to create many StockJournals.
   */
  data: Prisma.StockJournalCreateManyInput | Prisma.StockJournalCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StockJournalIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * StockJournal update
 */
export type StockJournalUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StockJournal
   */
  select?: Prisma.StockJournalSelect<ExtArgs> | null
  /**
   * Omit specific fields from the StockJournal
   */
  omit?: Prisma.StockJournalOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StockJournalInclude<ExtArgs> | null
  /**
   * The data needed to update a StockJournal.
   */
  data: Prisma.XOR<Prisma.StockJournalUpdateInput, Prisma.StockJournalUncheckedUpdateInput>
  /**
   * Choose, which StockJournal to update.
   */
  where: Prisma.StockJournalWhereUniqueInput
}

/**
 * StockJournal updateMany
 */
export type StockJournalUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update StockJournals.
   */
  data: Prisma.XOR<Prisma.StockJournalUpdateManyMutationInput, Prisma.StockJournalUncheckedUpdateManyInput>
  /**
   * Filter which StockJournals to update
   */
  where?: Prisma.StockJournalWhereInput
  /**
   * Limit how many StockJournals to update.
   */
  limit?: number
}

/**
 * StockJournal updateManyAndReturn
 */
export type StockJournalUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StockJournal
   */
  select?: Prisma.StockJournalSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the StockJournal
   */
  omit?: Prisma.StockJournalOmit<ExtArgs> | null
  /**
   * The data used to update StockJournals.
   */
  data: Prisma.XOR<Prisma.StockJournalUpdateManyMutationInput, Prisma.StockJournalUncheckedUpdateManyInput>
  /**
   * Filter which StockJournals to update
   */
  where?: Prisma.StockJournalWhereInput
  /**
   * Limit how many StockJournals to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StockJournalIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * StockJournal upsert
 */
export type StockJournalUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StockJournal
   */
  select?: Prisma.StockJournalSelect<ExtArgs> | null
  /**
   * Omit specific fields from the StockJournal
   */
  omit?: Prisma.StockJournalOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StockJournalInclude<ExtArgs> | null
  /**
   * The filter to search for the StockJournal to update in case it exists.
   */
  where: Prisma.StockJournalWhereUniqueInput
  /**
   * In case the StockJournal found by the `where` argument doesn't exist, create a new StockJournal with this data.
   */
  create: Prisma.XOR<Prisma.StockJournalCreateInput, Prisma.StockJournalUncheckedCreateInput>
  /**
   * In case the StockJournal was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.StockJournalUpdateInput, Prisma.StockJournalUncheckedUpdateInput>
}

/**
 * StockJournal delete
 */
export type StockJournalDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StockJournal
   */
  select?: Prisma.StockJournalSelect<ExtArgs> | null
  /**
   * Omit specific fields from the StockJournal
   */
  omit?: Prisma.StockJournalOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StockJournalInclude<ExtArgs> | null
  /**
   * Filter which StockJournal to delete.
   */
  where: Prisma.StockJournalWhereUniqueInput
}

/**
 * StockJournal deleteMany
 */
export type StockJournalDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which StockJournals to delete
   */
  where?: Prisma.StockJournalWhereInput
  /**
   * Limit how many StockJournals to delete.
   */
  limit?: number
}

/**
 * StockJournal.order
 */
export type StockJournal$orderArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Order
   */
  select?: Prisma.OrderSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Order
   */
  omit?: Prisma.OrderOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.OrderInclude<ExtArgs> | null
  where?: Prisma.OrderWhereInput
}

/**
 * StockJournal without action
 */
export type StockJournalDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the StockJournal
   */
  select?: Prisma.StockJournalSelect<ExtArgs> | null
  /**
   * Omit specific fields from the StockJournal
   */
  omit?: Prisma.StockJournalOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.StockJournalInclude<ExtArgs> | null
}
